<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>レトロドット変換（カメラ対応）</title>
<style>
  body { margin:0; font-family: system-ui, -apple-system, sans-serif; background:#0f1115; color:#e6e6eb; }
  header { padding:10px; text-align:center; }
  h1 { font-size:18px; margin:6px 0; }
  .panel { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; padding:8px; }
  .panel > * { background:#171a21; border:1px solid #2a2f3a; color:#e6e6eb; border-radius:8px; padding:6px 10px; }
  select, input, button { font-size:14px; }
  .stage { display:grid; grid-template-columns: 1fr; gap:8px; padding:8px; }
  .can-wrap { position:relative; background:#000; border:1px solid #2a2f3a; border-radius:10px; overflow:hidden; }
  canvas { width:100%; height:auto; max-height:80vh; display:block; image-rendering: pixelated; }
  video { display:none; }
  .palette-editor { display:flex; flex-wrap:wrap; gap:6px; justify-content:center; padding:6px; }
  .swatch { display:flex; align-items:center; gap:4px; background:#111; border:1px solid #2a2f3a; border-radius:999px; padding:4px 6px; }
  .swatch input[type="color"]{ width:28px; height:28px; border:none; background:none; }
  .footer { text-align:center; font-size:12px; opacity:.7; padding:6px 0 10px; }
  .hidden { display:none !important; }
</style>
</head>
<body>
<header>
  <h1>レトロ ドット & 変換（リアルタイム固定ランダム対応）</h1>
</header>

<div class="panel">
  <input type="file" id="file" accept="image/*">
  <label>ドット数 <input id="dotSize" type="number" value="100" min="8" max="512"></label>
  <label>色数 <input id="colorCount" type="number" value="8" min="2" max="16"></label>
  <select id="mode">
    <option value="preset">プリセット</option>
    <option value="random">ランダム</option>
    <option value="custom">手動</option>
  </select>
  <select id="preset">
    <option value="sunset2">Sunset 2 (8色)</option>
    <option value="mono8">モノクロ8色</option>
    <option value="gb8">ゲームボーイ風</option>
  </select>
  <button id="convert">変換</button>
  <button id="realtime">リアルタイム開始</button>
  <button id="switchCam">フロント/リア切替</button>
  <button id="shutter">シャッター保存</button>
  <button id="download">PNG保存</button>
</div>

<div id="paletteEditor" class="palette-editor"></div>

<div class="stage">
  <div class="can-wrap">
    <canvas id="canvas"></canvas>
    <video id="video" playsinline></video>
  </div>
</div>

<script>
const PRESETS = {
  sunset2: [
    [44,62,76],[66,75,82],[109,102,94],[163,132,104],
    [189,141,101],[211,158,108],[255,192,118],[204,206,185]
  ],
  mono8: [[0,0,0],[32,32,32],[64,64,64],[96,96,96],[128,128,128],[160,160,160],[200,200,200],[255,255,255]],
  gb8: [[15,56,15],[48,98,48],[139,172,15],[155,188,15],[200,220,80],[220,240,140],[240,255,200],[255,255,255]]
};

const fileInput = document.getElementById('file');
const dotSizeInput = document.getElementById('dotSize');
const colorCountInput = document.getElementById('colorCount');
const modeSelect = document.getElementById('mode');
const presetSelect = document.getElementById('preset');
const paletteEditor = document.getElementById('paletteEditor');
const convertBtn = document.getElementById('convert');
const realtimeBtn = document.getElementById('realtime');
const switchCamBtn = document.getElementById('switchCam');
const shutterBtn = document.getElementById('shutter');
const downloadBtn = document.getElementById('download');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const video = document.getElementById('video');

let img = new Image();
let stream = null;
let useFront = false;
let realtimeOn = false;
let rafId = null;

let customPalette = [];
let fixedRandomPalette = null; // ★固定ランダム

function hexToRgb(hex){ const n=parseInt(hex.replace('#',''),16); return [(n>>16)&255,(n>>8)&255,n&255]; }
function randomPalette(n){ return Array.from({length:n},()=>[Math.random()*255|0,Math.random()*255|0,Math.random()*255|0]); }

function buildPaletteEditor(n){
  paletteEditor.innerHTML = ''; customPalette=[];
  for(let i=0;i<n;i++){
    const w=document.createElement('div'); w.className='swatch';
    const c=document.createElement('input'); c.type='color'; c.value='#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
    c.oninput=drawFromImage; w.appendChild(c); paletteEditor.appendChild(w); customPalette.push(c);
  }
}

function getActivePalette(){
  const n=parseInt(colorCountInput.value,10);
  const mode=modeSelect.value;
  if(mode==='preset') return PRESETS[presetSelect.value].slice(0,n);
  if(mode==='random'){
    if(!fixedRandomPalette || fixedRandomPalette.length!==n){
      fixedRandomPalette = randomPalette(n);
    }
    return fixedRandomPalette;
  }
  return customPalette.map(i=>hexToRgb(i.value)).slice(0,n);
}

function fitSize(sw,sh,d){ const a=sw/sh; return sw>=sh ? [d, Math.max(1,Math.round(d/a))] : [Math.max(1,Math.round(d*a)), d]; }

function quantize(imgData, pal){
  const d=imgData.data;
  for(let i=0;i<d.length;i+=4){
    let r=d[i],g=d[i+1],b=d[i+2], best=pal[0], min=1e9;
    for(const p of pal){ const dr=r-p[0],dg=g-p[1],db=b-p[2]; const dist=dr*dr+dg*dg+db*db; if(dist<min){min=dist; best=p;} }
    d[i]=best[0]; d[i+1]=best[1]; d[i+2]=best[2];
  }
}

function drawFromImage(){
  if(!img.src) return;
  const [w,h]=fitSize(img.width,img.height,parseInt(dotSizeInput.value,10));
  canvas.width=w; canvas.height=h;
  ctx.drawImage(img,0,0,w,h);
  const id=ctx.getImageData(0,0,w,h);
  quantize(id, getActivePalette());
  ctx.putImageData(id,0,0);
}

fileInput.onchange=e=>{
  const f=e.target.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ img.onload=drawFromImage; img.src=r.result; };
  r.readAsDataURL(f);
};

convertBtn.onclick=()=>{
  if(modeSelect.value==='random'){
    fixedRandomPalette = randomPalette(parseInt(colorCountInput.value,10)); // ★ここで更新
  }
  drawFromImage();
};

function updatePaletteUI(){
  paletteEditor.classList.toggle('hidden', modeSelect.value!=='custom');
  if(modeSelect.value==='custom') buildPaletteEditor(parseInt(colorCountInput.value,10));
}
modeSelect.onchange=updatePaletteUI;
colorCountInput.onchange=()=>{ if(modeSelect.value==='custom') buildPaletteEditor(parseInt(colorCountInput.value,10)); };
updatePaletteUI();

async function startCamera(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode: useFront?'user':'environment' }, audio:false });
  video.srcObject = stream; await video.play();
}
function drawFromVideo(){
  if(!realtimeOn) return;
  const [w,h]=fitSize(video.videoWidth||640, video.videoHeight||480, parseInt(dotSizeInput.value,10));
  canvas.width=w; canvas.height=h;
  ctx.drawImage(video,0,0,w,h);
  const id=ctx.getImageData(0,0,w,h);
  quantize(id, getActivePalette());
  ctx.putImageData(id,0,0);
  rafId=requestAnimationFrame(drawFromVideo);
}
realtimeBtn.onclick=async()=>{
  realtimeOn=!realtimeOn;
  realtimeBtn.textContent = realtimeOn?'リアルタイム停止':'リアルタイム開始';
  if(realtimeOn){ await startCamera(); drawFromVideo(); }
  else { if(rafId) cancelAnimationFrame(rafId); if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } }
};
switchCamBtn.onclick=async()=>{ useFront=!useFront; if(realtimeOn) await startCamera(); };

shutterBtn.onclick=()=>canvas.toBlob(b=>{ const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download='retro_shot.png'; a.click(); URL.revokeObjectURL(u); });
downloadBtn.onclick=()=>{ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='retro.png'; a.click(); };
</script>
</body>
</html>
